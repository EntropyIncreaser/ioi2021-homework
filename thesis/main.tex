\newcommand{\di}{\ensuremath{\mathrm{\,d}}}
\newcommand{\Mul}{\ensuremath{\mathsf M}}
\newcommand{\A}{\ensuremath{\mathbb A}}
\newcommand{\R}{\ensuremath{\mathsf R}}
\newcommand{\IZ}{\ensuremath{{I \backslash \{0\}}}}
\newcommand{\me}{\mathrm{e}}

\newcommand\DOI[1]{doi: \href{http://doi.org/#1}{\texttt{#1}}}
\newcommand\ARXIV[1]{arxiv: \href{https://arxiv.org/abs/#1}{\texttt{#1}}}

\makeatletter
\newenvironment{breakablealgorithm}
  {% \begin{breakablealgorithm}
   \begin{center}
     \refstepcounter{algorithm}% New algorithm
     \hrule height.8pt depth0pt \kern2pt% \@fs@pre for \@fs@ruled
     \renewcommand{\caption}[2][\relax]{% Make a new \caption
       {\raggedright\textbf{\ALG@name~\thealgorithm} ##2\par}%
       \ifx\relax##1\relax % #1 is \relax
         \addcontentsline{loa}{algorithm}{\protect\numberline{\thealgorithm}##2}%
       \else % #1 is not \relax
         \addcontentsline{loa}{algorithm}{\protect\numberline{\thealgorithm}##1}%
       \fi
       \kern2pt\hrule\kern2pt
     }
  }{% \end{breakablealgorithm}
     \kern2pt\hrule\relax% \@fs@post for \@fs@ruled
   \end{center}
  }
\makeatother

\begin{abstract}
生成函数近年来在信息学竞赛的组合计数问题中扮演着越加重要的角色。其用途在问题处理时的公式推导，以及代码实现中的学问均已逐渐普及。本文旨在给出一套生成函数在信息学竞赛实战中处理问题的方法框架，同时梳理一些其中的重要算法。
\end{abstract}

\ifcont

\tableofcontents

\newpage

\fi

\section{概述}

当我们得到一个组合计数问题相关的生成函数解后，其代数形式到答案计算的算法的转化过程仍有若干壁垒。究其原因，我们在进行计算时常常受到以下几个复杂对象的制约。

\subsection{复合}

相对于卷积，我们在形式幂级数问题上没有非常高效的处理一般复合问题的方法。多项式模复合问题在 OI 中已经被引入的复杂度最优的算法为 $\Theta((n\log n)^{3/2})$，且该算法具有较大的常数，在实战中往往 $\Theta(n^2)$ 次运算的一种“分块 FFT”算法具有更好的表现。值得一提的是，该问题在理论界已有 $O(n^{1+o(1)})$ 的算法（见 \cite{polyfact}），但尚不清楚在实现上是否优越。

\subsection{生成函数方程}

\subsection{远处系数求值}

远处系数求值意谓在提取第 $n$ 次项系数时，往往 $\Omega(n)$ 的计算量都是不被允许的。而能在 $o(n)$ 时间内完成计算的问题要求确实比较苛刻，但目前仍有一些可探讨的空间。目前较为成熟的两类远处系数求值是\emph{线性递推数列}和\emph{整式递推数列}。

\begin{theorem}给定数列 $a_n$ 的 $0\sim k-1$ 项和定义在其上的线性递推式 $b_1,\dots, b_k$，满足
$$ a_n = \sum_{j=1}^k a_{n-j} b_j $$

存在算法在 $\Theta(k\log k\log n)$ 时间内计算 $a_n$。
\end{theorem}

现在较为普及的线性递推算法由 Fiduccia 于 1985 年提出，并不具有较好的常数。后文将介绍一种算法上更为简单，且具有较好常数的线性递推算法。

\begin{theorem}给定数列 $a_n$ 的 $0\sim m-1$ 项和定义在其上的整式递推式 $P_0,\dots,P_m$，满足
$$ a_n = -\frac1{P_0(n)}\sum_{j=1}^m a_{n-j}P_j(n) $$

存在算法在 $\Theta \left(\sqrt{nd}\left(m^3+m^2\log(nd)\right)\right)$ 时间内计算 $a_n$。
\end{theorem}

\subsection{线性变换}

\paragraph{转置原理} \cite{tellegen} 指出，在考虑一类可表示为对输入向量 $\mathbf x$ 进行矩阵乘法 $\mathbf {Mx}$ 的计算时，可考虑先对 $\mathbf M^{\mathsf T}\mathbf y$ 的计算设计算法，然后将算法的各步骤转置改写。

\section{算法的评定} 

\subsection{系数}

在信息学竞赛的组合计数问题中，由于问题常常要求输出对某个数取模的结果，而这一计算方式往往会影响算法的使用。其对计算复杂程度的影响大致可分为以下四级。

\begin{center}
\begin{tikzcd}[row sep=tiny, column sep=small]
			\mathbb F_{\mathsf{NTT}} \arrow[phantom, r, "\subset" description] & \mathbb F_p \arrow[phantom, r, "\subset" description] & \mathrm{GF}(p^k) \arrow[phantom, r, "\subset" description] & \mathsf{Commutative\ Rings} \\
			\text{NTT 模数域} & \text{素数域} & \text{有限域} & \text{交换环}
\end{tikzcd}
\end{center}

\begin{asparadesc}
\item [NTT 模数域] 设取模的素数 $p$ 满足 $p= m\times 2^k+1$，当 $k$ 较大时，由于 $2^k$ 次单位根的存在，快速数论变换可以在 $\Theta(n\log n)$ 时间内进行长度为 $2$ 的幂，且最长为 $2^k$ 的数论意义下 DFT 结果。由此即可对于 $n\le 2^k$，在 $\Theta(n\log n)$ 的时间内完成两个 $n$ 次多项式的乘法。由于其 DFT 的存在，在这种模数下的算法往往有很大的，根据 DFT 中间结果进行针对性常数优化的空间。

\begin{itemize}
\item \emph{模 $998244353$}：NTT 模数中最为著名的非 $\mathbb F_{998244353}$ 莫属，有 $998244353 = 119\times 2^{23} + 1$。
\end{itemize}

\item [素数域] 在题目中要求答案同余一个素数也较为常见，其中又有大多数情况 $p$ 很大（例如 $10^9+7$），通常是为了保证算法中可以较自由地进行除法。

\item [有限域] 对于一个 $\mathbb F_p$ 上的 $n$ 阶不可约多项式 $f$，$\mathbb F_p[x]/f$ 为一 $p^n$ 阶有限域，记为 $\mathrm{GF}(p^n)$。

\begin{itemize}
\item \emph{Nimber}：Nimber 是一种可以较为高效计算的有限域，其出现时往往为 $\mathrm{GF}(2^{32})$ 或 $\mathrm{GF}(2^{64})$，与计算机的无符号整数 \texttt{uint32} 或 \texttt{uint64} 交相呼应。
\item \emph{二次扩域}：题目中较为常见的是二次扩域，实际上就是对于模 $p$ 下的二次非剩余 $r$，模拟 $a + b\sqrt r$ 的运算。这实际上就等价于 $\mathbb F_p[x]/(x^2-r)$，由 $r$ 是二次非剩余可知 $x^2-r$ 是不可约多项式，故前式是域。
\end{itemize}

\item [交换环] 交换环中不一定有逆，因此并不总能进行除法。

\begin{itemize}
\item \emph{模 $n$ 运算}：$\mathbb Z/n\mathbb Z$ 在 $n$ 是合数时不构成域。
\item \emph{多项式}：若多项式的元素仅构成交换环，或者运算时对一可约多项式取模都会导致运算不构成域，只构成交换环。
\end{itemize}

\item [杂项] 还有部分性质极差的运算，它们并非本文想要讨论的重点，仅简单提及。

\begin{itemize}
\item \emph{矩阵环}：矩阵的乘法是信息学竞赛中最常见的非交换运算。由于其非交换性，在诸如生成函数乘法逆的计算时需要注意运算顺序，而诸如生成函数 $\exp$ 等运算并不具有很好的性质，尚未有复杂度优秀的算法。
\item \emph{最值与最值计数}：最值与最值计数仅构成交换半环，由于目前 max-plus 卷积尚未有 $O(n^{2-\epsilon})$ 的算法，限于其算术性质与本文相离太远，故仅在此提及。
\end{itemize}

\end{asparadesc}

在接下来的表述中，我们默认计算时的系数至少为交换环，记为 $\A$。

\subsection{序列变换}

\subsubsection{卷积}

\begin{definition} [卷积下标系统]
我们称满足以下几条性质的集合 $I$ 以及定义在其上的运算 $\circ$ 构成下文要讨论的\emph{卷积下标系统}：
\begin{itemize}
\item \emph{结合律}：即 $\forall i,j,k\in I$，有 $(i\circ j)\circ k = i\circ(j\circ k)$。
\item \emph{交换律}：对于 $\forall i,j\in I$，有 $i\circ j = j\circ i$。
\item \emph{单位元}：存在元素 $1 \in I$，对于 $\forall i\in I$，有 $1\circ i = i$。
\item \emph{零元}：存在元素 $0\in I$，对于 $\forall i\in I$，有 $0\circ i = 0$。
\item \emph{后效律}：对于 $\forall i \in \IZ$，对任意正整数 $k$ 和 $j_1,\dots,j_k \in I\backslash \{0,1\}$ 有 $i\circ j_1\circ \dots \circ j_k \neq i$。
\end{itemize}
下文中如有歧义时则用 $0_I, 1_I$ 表示 $0,1$。在讨论卷积下标系统时，默认以 $I$ 表示 $(I, \circ)$。在讨论算法时，我们默认 $I$ 是有限的。
\end{definition}

\begin{definition} [生成函数]
对于以卷积下标系统 $I$ 为下标的序列 $\{f_i \in \A\}_{i\in \IZ}$，我们定义其生成函数 $F(X) = \sum_{i\in I} f_i X^i$，我们记 $X$ 为“未定元”，满足：

\begin{itemize}
\item 对 $\forall a\in \A, i\in I$，有 $aX^i = X^i a$。
\item 对 $\forall i,j\in I$，有 $X^i \cdot X^j = X^{i\circ j}$。
\item \emph{消去律}：$X^{0_I} = 0_{\A}$，即 $X^{0_I}$ 作为生成函数对应的序列为 $\{f_i = 0_{\A}\}_{i\in \IZ}$。
\item $X^{1_I} = 1_{\A}$。
\end{itemize}

\end{definition}

容易看出，前文所定义的\emph{零元}刻画了在计算时溢出的部分。

我们记这样的全体生成函数 $F(X)$ 构成的环为 $\mathfrak G[X]$。

我们所选取的生成函数进行乘法时，未定元指标的运算自然地导出了对应系数序列的卷积。

\begin{definition} [卷积]
对于以卷积下标系统 $I$ 为下标，以 $\A$ 为系数的序列，我们定义其卷积 $c = a * b$：
$$
c_k = \sum_{i\circ j = k} a_i b_j
$$
\end{definition}

\subsubsection{在线算法}

通过前文的铺垫，我们接下来叙述一个静态的算法与其\emph{在线}形式的关联。

\begin{definition} [后效序]
定义 $I$ 上的序关系 $\preceq$：$i\preceq j$ 当且仅当存在 $k \in I$，使得 $i \circ k = j$。我们称这一序关系为\emph{后效序}。
\end{definition}

\begin{lemma}
$I$ 上的后效序构成偏序。且以 $1$ 为最小元，以 $0$ 为最大元。
\end{lemma}

读者不难根据偏序集的定义逐条验证此引理。

\begin{definition} [后效变换]
对于变换 $\Psi: \underbracket{\A^\IZ \times \cdots \times \A^\IZ}_{\text{$n$ 个}} \rightarrow\A^\IZ$，我们称其为\emph{后效}的，当且仅当对于 $\forall i\in \IZ$，令 $J=\{j \mid j \preceq i\}$，任取 $a^{(1)}, \dots, a^{(n)}$，记 $\psi = \Psi [a^{(1)}, \dots, a^{(n)}]$，改变任何一者在 $I \backslash J$ 中的取值，都不会改变 $\psi_i$。
\end{definition}

\begin{lemma}
卷积变换是后效的。
\end{lemma}

\begin{definition} [多项式左复合]
我们总是可以定义多项式与一个生成函数的复合。记多项式 $F(x) = \sum_{k=0}^n f_k x^k$ 和序列 $g$ 对应的生成函数 $g(X)$。则复合 $h = f \circ g$ 定义为
$$
h(X) = \sum_{k=0}^n f_k g(X)^k
$$
\end{definition}

\begin{lemma}
多项式的左复合关于 $g$ 是后效的。
\end{lemma}

\begin{definition} [在线算法]
对于一具有 $n$ 个输入的后效变换 $\Psi$ 以及对于一个保后效序的优先级 $\delta: \IZ \rightarrow \mathbb Z_{\ge 0}$，满足 $i \prec j \Rightarrow \delta(i) < \delta(j)$，我们称一个算法是\emph{在线}计算 $\Psi$ 的当其能配合黑盒完成以下流程：
\begin{enumerate}
\item 令 $a^{(1)}, \dots, a^{(n)}$ 所有项均为 $0$。

\item 将 $k$ 从 $0$ 循环至最大的 $\delta$ 值，记 $J_k = \{ j \mid \delta(j) = k \}$。设此时 $\psi^{(k)} = \Psi[a^{(1)}, \dots, a^{(n)}]$，对于全体 $j\in J_k$，将 $\psi^{(k)}_j$ 汇报给黑盒。$J_k$ 中所有元素汇报结束后，黑盒对于所有 $1\le i\le n, j\in J_k$，将 $a^{(i)}_j$ 赋值。
\end{enumerate}
\end{definition}

接下来，我们不难注意到：

\begin{lemma}
设问题规模为 $n$，由一系列分别可在 $T_1(n),\dots,T_k(n)$ 时间内完成在线算法的后效变换 $\Psi_1,\dots, \Psi_k$ 构成的\emph{表达式树}，不妨将其整体看做一个变换 $\Phi$，该变换是后效的，且存在 $T_1(n) + \cdots + T_k(n)$ 时间的在线算法。
\end{lemma}

\subsection{线性算子}

\begin{definition}[微分型算子]
对于生成函数环 $\mathfrak G[X]$，我们称作用在其上的一个线性算子 $\mathfrak D$ 是\emph{微分型}的，当且仅当其满足条件 $\forall f,g\in \mathfrak G[X] \Rightarrow \mathfrak D(fg) = f\mathfrak D g+g\mathfrak D f$。
\end{definition}

这与我们常见的导数算子是符合的，由此我们容易得到以下推论：

\begin{lemma}
对于一个多项式 $f$ 和一个 $\mathfrak G[X]$ 上的生成函数 $g$，有
$$
\mathfrak D (f\circ g) = (f' \circ g) \mathfrak D g
$$
\end{lemma}

\begin{lemma}
对于微分型算子 $\mathfrak D_1$ 和 $\mathfrak D_2$，其线性组合 $u\mathfrak D_1 + v\mathfrak D_2$ 也是微分型算子，其中 $u,v\in \mathfrak G[X]$。
\end{lemma}

而除了微分型算子，还有以下两类算子是容易见到的。

\begin{definition}[下标变换算子]
对于 $n\in \mathbb Z_{\ge 0}$，我们称作用在生成函数上的线性算子 $\mathfrak S_n$ 满足 $\mathfrak S_n X^j = X^{nj} = X^{\underbracket{j\circ \dots\circ j}_{\text{$n$ 个}}}$，全体 $\mathfrak S_n$ 构成\emph{下标变换算子}。
\end{definition}

这类算子广泛出现于 P\"olya 计数中。

\begin{definition}[点乘算子]
对于数列 $\{a_i\}_{i\in \IZ}$，对应的线性算子 $\mathfrak d_a$ 满足 $\mathfrak d_a X^i = a_iX^i$，我们称之为\emph{点乘算子}。
\end{definition}

\subsection{方程求解}

经过前文的铺垫，至此解出方程所有项系数的通用方法已经是图穷匕见了，其两大主要方法为在线方法和牛顿迭代法。

\paragraph{在线方法}

在线方法意为

\paragraph{牛顿迭代法}

\section{普通生成函数}

\begin{definition}[普通生成函数]
令 $I=\mathbb Z \cap [0, n] \cup \{0_I\}$，且对于 $i,j \in I\backslash\{0_I\}$，定义

$$
i\circ j =\begin{cases}
i + j & i + j \le n\\
0_I & \mathrm{else}
\end{cases}
$$

定义在 $(I,\circ)$ 上的生成函数即为我们计算时取的普通生成函数（OGF）。

\end{definition}

可见，这实际上就是对于形式幂级数 $\bmod x^{n+1}$。

\subsection{卷积}

\begin{theorem}[快速 Fourier 变换]
对于形如模 $M$ 运算的环，可以在 $\Theta(n\log n)$ 次运算内完成卷积的计算。
\end{theorem}

最常见的情况为 $M$ 是 NTT 模数。而对一般的 $M$，常使用三模数 NTT 或者拆系数 FFT 在较大常数的 $\Theta(n\log n)$ 内完成计算。

下文中，我们以 $\Mul(n)$ 表示多项式乘法的复杂度。

\subsubsection{半在线卷积}

\begin{definition}[半在线卷积]
在计算序列 $a,b$ 的卷积时，若算法仅关于序列 $b$ 是在线的，序列 $a$ 初始已经完全确定，那么称这一算法计算了\emph{半在线卷积}。记其复杂度为 $\mathsf S(n)$。
\end{definition}

\begin{theorem}

目前复杂度最好的半在线卷积经 \cite{relaxmul} 分析为
$$
\mathsf{S}(n) = O\left(n\log n\mathrm{e}^{2\sqrt{\log 2\log\log n}}\right)
$$
\end{theorem}

注意到对于 $\forall \epsilon > 0$，都有 $\mathsf{S}(n) = o\left(n\log^{1+\epsilon} n\right)$，因此在理论上半在线卷积与卷积的复杂度是极为接近的。而在实际应用中较易实现的算法实为 $\Theta \left( \frac{n\log ^2 n}{\log \log n} \right)$。在 \cite{nimberpoly} 中已有介绍，不予赘述。

\begin{theorem}
在线卷积与半在线卷积等难。即记在线卷积的复杂度为 $\R(n)$，那么有
$$
\R(n)=\Theta(\mathsf S(n))
$$
\end{theorem}

首先半在线卷积显然可以规约为在线卷积，接下来进行逆向规约。我们通过倍增来构造一种 $\Theta(\mathsf S(n))$ 计算在线卷积的算法：

\begin{enumerate}
\item 令 $m=\lfloor n/2\rfloor$，首先进行 $0\sim m$ 下标部分的在线卷积。
\item 接下来考虑 $k > m$ 的部分，考虑卷积式 $c_k = \sum_{i=0}^k a_ib_{k-i}$，注意到 $\min(i,k-i)\le \frac k2$，因此 $i,k-i$ 中必有一者 $\le m$。
\item 因此考虑将剩下的计算分为三部分：
\begin{itemize}
\item $i,j\le m$，这部分可以立刻 $\Mul(m)$ 算出。 
\item $i\le m,j>m$，这实际上是 $a_{0\sim m}$ 与 $b_{m+1\sim n}$ 部分的半在线卷积。
\item $j\le m,i>m$，这实际上是 $b_{0\sim m}$ 与 $a_{m+1\sim n}$ 部分的半在线卷积。
\end{itemize}
\item 因此算法只需倍增地进行半在线卷积，有递归式 $\R(n) = \R(n/2) + \Theta(\mathsf S(n))$。
\item 根据主定理，有 $\R(n)=\Theta(\mathsf S(n))$。
\end{enumerate}

\subsection{方程求解}

\subsubsection{牛顿迭代法}

\subsubsection{Lagrange 反演}

对于一元生成函数来说，Lagrange 反演有效地将一个生成函数与其复合逆的系数建立起了联系。为体现形式的优美性，我们需在形式 Laurent 级数下描述 Lagrange 反演。本文中只展示一个在特征为 $0$ 的域上的证明方法，在一般环上的通用证明可参看 \cite[Sec. 1.2]{combenum}。

\begin{definition}[形式 Laurent 级数]
记域 $K$ 上的形式 Laurent 级数为 $K((x))$ 或 $K[[x]][x^{-1}]$，即对于 $f(x) \in K((x))$，若 $f\neq 0$，则存在数列 $\{a_n\}_{n\ge n_0}$，有
$$
f(x) = x^{n_0} \left(\sum_{n\ge 0} a_{n+n_0} x^n\right)
$$

其中有 $a_{n_0} \neq 0$。

此时对于 $k\in \mathbb Z$，容易定义在 $K((x))$ 内的幂 $f^k$：
$$
f(x)^k = x^{n_0 k} \left(\sum_{n\ge 0} a_{n+n_0} x^n\right)^k
$$
\end{definition}

\begin{lemma}[形式留数]
对于幂级数 $F(x)$ 满足 $n_0 = 1$，那么对于 $\forall k\in \mathbb Z$，有
$$
[x^{-1}]F'(x)F^k(x)=[k=-1]
$$
\end{lemma}

\begin{proof} 考虑当 $k\neq -1$ 时，我们有 $F'(x)F^k(x)=(\frac 1{k+1} F(x)^{k+1})'$，而 $(x^0)'=0x^{-1}$，故 $-1$ 次项系数此时必然为 $0$。当 $k=-1$ 时设 $F(x) = a_1 x + a_2 x^2 + \cdots$，有

\begin{align*}
\frac{F'(x)}{F(x)} &= \frac{a_1 + 2a_2x + \cdots}{a_1 x + a_2 x^2 + \cdots}\\
&= x^{-1} \frac{1 + 2\frac{a_2}{a_1} x + \cdots}{1 + \frac{a_2}{a_1} x + \cdots}
\end{align*}

因此 $k=-1$ 时 $-1$ 次项系数为 $1$。
\end{proof}
\begin{theorem}[Lagrange 反演]
对于幂级数 $F(x)$ 满足 $n_0 = 1$ 以及 $G(x)$ 满足 $F(G(x))=x$ 是其复合逆，那么对于 $n,k\in \mathbb Z$，有

$$
n[x^n]F(x)^k = k[x^{-k}]G(x)^{-n}
$$
\end{theorem}

\begin{proof}
我们考虑带入复合关系 $F(G(x))=x$，有
\begin{align*}
F(G(x))^k &= x^k\\
(F^k)'(G)G' &= kx^{k-1}\\
\sum_{i} i([x^i] F^k(x)) G^{i-1}G' &= kx^{k-1}\\
\sum_{i} i([x^i] F^k(x)) G^{i-1-n}G' &= kx^{k-1}G^{-n}\\ 
[x^{-1}]\sum_{i} i([x^i] F^k(x)) G^{i-1-n}G' &= [x^{-1}]kx^{k-1}G^{-n}\\ 
n[x^n] F^k &= [x^{-1}]kx^{k-1}G^{-n}\\ 
n[x^n] F^k &= k[x^{-k}]G^{-n}
\end{align*}
故原式得证。
\end{proof}

与这一富有对称性的形式相比，这一公式在以往更加流行的版本则是一个复合形式。

\begin{lemma}
对于幂级数 $H(x) \in K((x))$，有

$$
[x^n]H(F(x)) = \frac 1n [x^{n-1}] H'(x) \left(\frac x{G(x)}\right)^n
$$
\end{lemma}

读者只需确认 $H(x) = x^k$ 的情况即可验证，在此不予赘述。

\begin{problem}[Slime and Sequences]\footnote{来源：许庭强与本人共同命制，\url{http://codeforces.com/problemset/problem/1349/F2}，已省略得到生成函数的推导过程}
计算 $[z^n]\frac{t(\me^{z(1-t)}-1)}{(1-z)(1-t\me^{z(1-t)})}$ 的系数同余 $998244353$，保证 $1\le n\le 10^5$。
\end{problem}

\begin{solution} 考虑 $\left([z^n]\frac{t(\mathrm e^{z(1-t)}-1)}{(1-z) (1-t \mathrm e^{z(1-t)})}\right) + 1 = (1-t)[z^n] \frac 1{(1-z)(1-t\mathrm e^{z(1-t)})}$，用于简化表达式。

接下来我们令 $z = \frac u{1-t}$，就有
$$
[z^n]\frac 1{(1-z)(1-t\mathrm e^{z(1-t)})} = (1-t)^n[u^n] \frac1{(1-\frac u{1-t})(1-t\mathrm{e}^u)}
$$

接下来做分式分解
\begin{align*}
 &\quad (1-t)[z^n] \frac 1{(1-z)(1-t\mathrm e^{z(1-t)})}\\
 &= [u^n]\frac{(1-t)^{n+2}}{(1-\frac{t}{1-u})(1-t\mathrm e^u)(1-u)}\\
 &= (1-t)^{n+2} [u^n] \left(\frac{-\mathrm e^u}{\left(\mathrm e^u u-\mathrm e^u+1\right) \left(1-t \mathrm e^u\right)}+\frac{\frac{1}{1-u}}{\left(\mathrm e^u   u-\mathrm e^u+1\right) (1-\frac{t}{1-u})}\right)\end{align*}

由此，问题的关键转化为提取 $[u^n] \frac{-\mathrm e^u}{\left(\mathrm e^u u-\mathrm e^u+1\right) \left(1-t \mathrm e^u\right)}$ 部分，我们设 $F(u) = \me^u-1$，那么即可将 BGF 表为 $A(F)/(1-t(1+F))$ 的形式，由复合逆 $G=\ln(1+u)$ 可得：
\begin{align*}
[u^n] \frac{A(F)}{(1-t(1+F))}
&= \frac 1n[u^{n-1}] \left(\frac{A(u)}{1-t(1+u)}\right)' \left(\frac u{G(u)}\right)^n\\
&= \frac 1n[u^{n-1}] \left( \frac{tA(u)}{(1-t(1+u))^2} + \frac{A'(u)}{1-t(1+u)} \right) \left(\frac u{G(u)}\right)^n
\end{align*}

由此，关键在于计算 $A(u)$ 的系数表示，由 $A(F(u)) = \frac{-\mathrm e^u}{\left(\mathrm e^u u-\mathrm e^u+1\right)}$ 可知 $A(u) = \frac{-\mathrm e^G}{\left(\mathrm e^G G-\mathrm e^G+1\right)}$。至此，问题可以在 $\Theta(n\log n)$ 时间内解决。
\end{solution}

上述常称为的「扩展 Lagrange 反演」虽然已经很强大，但还是有所不便之处：若扩展到一般环 $R$ 上，若 $F(x)$ 的一次项在 $R$ 中可逆，可知 $G$ 还是良定义的，但上述公式会需要 $n$ 在 $R$ 中可逆，不一定能帮我们计算出结果。最极端的情况便是这一公式无法告诉我们如何对于 $n=0,k<0$ 的情况提取系数。因此，我们有时需要考虑一个变式：

\begin{lemma}[另类 Lagrange 反演]
保持原先条件不变，有
$$
[x^n]F^k = [x^{-k-1}]G'G^{-n-1}
$$
\end{lemma}

\begin{proof} 我们在第一步不是求导，而是乘以 $G'G^{-n-1}$，就会有
\begin{align*}
F(G(x))^k &= x^k\\
\sum_i ([x^i]F^k(x))G^i &= x^k\\
\sum_i ([x^i]F^k(x))G'G^{i-n-1} &= x^k G'G^{-n-1}\\
[x^{-1}]\sum_i ([x^i]F^k(x))G'G^{i-n-1} &= [x^{-1}]x^k G'G^{-n-1}\\
[x^n]F^k &= [x^{-1}]x^k G'G^{-n-1}\\
&= [x^{-k-1}]G'G^{-n-1}
\end{align*}
\end{proof}

这个形式虽然不再具有足够的对称性，却成功规避了除法。我们也可将其写作复合形式。

\begin{lemma} 在上一引理的相同条件下，有
$$
[x^n] H(F(x)) = [x^n]H(x)\left(\frac{x}{G(x)}\right)^{n+1}G'(x)
$$
\end{lemma}

其证明依然大同小异，不予赘述。

\begin{problem}[简单的普及组计数]\footnote{来源：戴江齐，加强自 \url{https://acm.nflsoj.com/problem/308}，已省略得到生成函数的推导过程}\label{pjcount}
设幂级数 $F(x)$ 满足 $F = \frac x{(1-(m-1)F)^{k-1}}$，求 $[x^n]\frac 1{1-mF}$ 同余质数 $p$，保证 $1\le n,k\le 10^9, 1\le m < p\le 10^5$。
\end{problem}

\begin{solution}
可得 $F$ 的复合逆为 $G=x(1+(m-1)x)^{k-1}$，根据另类 Lagrange 反演，有
\begin{align*}
[x^n] \frac 1{1-mF}
&= [x^n]\frac 1{1-mx}\left(\frac{x}{G(x)}\right)^{n+1}G'(x)\\
&= [x^n]\frac 1{1-mx}(1-(m-1)x)^{-(k-1)(n+1)} \cdot (1-(m-1)x)^{k-2}(1-(m-1)kx)\\
&= [x^n]\frac 1{1-mx}(1-(m-1)x)^{-kn+n-1}(1-(m-1)kx)
\end{align*}

由于模数很小，我们可以进行一个类似数位 DP 的过程，现在所求的答案形如 $[x^n] \frac 1{1-mx}(1-(m-1)x)^mf(x)$，由 Lucas 定理 $\binom {np+n_0}{mp+m_0} \equiv \binom n m\binom{n_0}{m_0} \pmod p$ 可知，设 $m=m_1p+r$ 和 $n=n_1p+s$ 则有
\begin{align*}
&\quad [x^n] \frac 1{1-mx}(1-(m-1)x)^mf(x)\\
&\equiv [x^n] (1-mx)^{-p+(p-1)}(1-(m-1)x)^{m_1p+r} f(x)\\
&\equiv [x^{n_1p+s}] \frac 1{1-mx^p}(1-(m-1)x^p)^{m_1} (f(x)(1-mx)^{p-1}(1-(m-1)x)^r)\\
&\equiv [x^{n_1}] \frac 1{1-mx}(1-(m-1)x)^{m_1} f_1(x)
\end{align*}
其中 $f_1(x)$ 是 $f(x)(1-mx)^{p-1}(1-(m-1)x)^r$ 提取同余 $p$ 余 $s$ 的下标系数所得，可以在 $\Theta(p\cdot \deg f)$ 内计算，归纳可知在 $f\leftarrow f_1$ 这一迭代过程中，始终有 $\deg f \le 1$。因此复杂度为单轮复杂度 $\Theta(p)$ 乘以迭代轮数 $\log_p n$，即 $\Theta(p\log_p n)$。
\end{solution}

\subsection{远处系数求值}

\subsubsection{线性递推}

接下来我们介绍一种线性递推式求值的\emph{低位优先算法}（LSB-first, least significant bit first）。

不同于 Fiduccia 直接通过快速幂对于 $x^n \bmod Q(x)$ 的考虑，低位优先算法的主要思想是考虑将线性递推转化为生成函数的形式 $\frac{P(x)}{Q(x)}$。注意我们容易在 $\mathsf M(k)$ 的时间内得到 $P(x)$，$\left(\sum_{i=0}^{k-1} f_i x^i\right) \cdot Q(x)$ 的 $0\sim k-1$ 项即为所求。接下来我们考虑如下等式：
$$
\frac {P(x)}{Q(x)} = \frac{P(x)Q(-x)}{Q(x)Q(-x)}
$$
我们注意记 $V(x)=Q(x)Q(-x)$，分析系数可以发现 $V(x)$ 只有偶次项有值，因此我们就得到了分解
$$
\frac{P(x)}{Q(x)} = \frac {E(x^2)}{U(x^2)} + x\frac {O(x^2)}{U(x^2)}, \quad U(x^2)=Q(x)Q(-x)
$$
因为这分别填满了二进制的 $0$ 和 $1$ 位，所以我们只需递归到一侧即可。而 $n \leftarrow \lfloor n/2 \rfloor$。

因此每轮都在 $\Theta(\Mul(k))$ 时间内完成计算，进行 $\log_2 n$ 轮迭代后，已经有 $n=0$，故算法复杂度为 $\Theta(\Mul(k)\log n)$。

这一算法还有许多优化的空间，在我们通常有 NTT 模数的情况下，\emph{同样的 FFT 实现可以让我们的常数大约是原先方法的} $\frac {1}{3}$。受篇幅所限，本文略过其优化细节。

这一过程每次仅用到了多项式乘法，并不需要实现多项式求逆。总的来说，本算法具有实现和效率方面的双重优越性。

%\subsubsection{小特征有限域代数幂级数}

% 在利用 OGF 进行计数时，一大类问题的结果都在代数幂级数的范畴之内。例如表示一类网格路径数量的 Catalan 数 $C(x)=\frac{1-\sqrt{1-4x}}{2x}$、大 Schr\"oder 数 $G(x)=\frac{1-x-\sqrt{1-6x+x^2}}{2x}$、Motzkin 数 $M(x)=\frac{1-x-\sqrt{1-2x-3x^2}}{2x^2}$。在进行远处系数求值时，一种具有普遍性的方法是找到数列的一个整式递推式，这一方法在 \cite{zzq} 中已有阐述。然而整式递推式中往往有分母。若 $\A$ 取 $\operatorname{char} K = O(n)$ 的有限域，则大多会在分母中出现 $0$，导致整个方法的失效。

%然而当有限域的特征 $p$ 较小时，这一条件引导我们发觉新的性质，其中最为关键的便是 Lucas 定理的一个推论。

%\begin{theorem}
%对于特征为 $p$ 的域 $K$，任取形式幂级数 $f\in K[[x]]$，有
%$$
%f(x)^p = \left( \sum_{n\ge 0} a_n x^n \right)^p = \sum_{n\ge 0} a_n^p x^{np}
%$$
%\end{theorem}

%\begin{proof}
%首先我们考虑二项式系数 $\binom p k \bmod p$，根据质因子分解 $\binom pk = \frac{p!}{k!(p-k)!}$ 可知只有 $k=0$ 或 $p$ 时，该式子不含有质因子 $p$，因此 $\binom p k \bmod p$ 在 $k=0$ 或 $p$ 时取值为 $1$，否则为 $0$。
%只需证明对任意 $n$ 的任意 $n$ 次多项式成立，设多项式 $f(x) = f_0(x) + a_nx^n, \deg f_0 < n$，考虑对 $(f_0(x) + a_nx^n)^p$ 二项式展开，由前述分析可知在 $K$ 中由于特征为 $p$，只会余下 $f_0(x)^p + (a_nx^n)^p$，后者也即 $a_n^px^{np}$，由归纳可知成立。
%\end{proof}

%寻此定理，我们将构建出一种不同的递推式。在例题 \ref{pjcount} 中我们对此法已有惊鸿一瞥。接下来主要将 \cite{palg} 的方法从 $\mathbb F_p$ 改进至 $\mathrm{GF}(p^k)$。

%\begin{definition}[$p$-进制方程]
%对于特征为 $p$ 的有限域 $K=\mathrm{GF}(p^k)$，我们称生成函数 $F(x)$ 满足一个 $n$ 阶 $p$-进制方程当且仅当对于 $0\le i\le n$，定义在 $P_i(x)\in K[x]$ 上有
%$$
%\sum_i P_{i}(x)F_i(x^{p^i}) = 0
%$$
%其中，设 $F(x)=\sum_{n\ge 0}f_nx^n$，记 $F_i(x)=\sum_{n\ge 0}f_n^{p^i}x^n$。
%\end{definition}

%易见，这样的生成函数方程

\section{多元幂级数}

\begin{definition}
对于 $1\le j\le k$ 设 $\mathfrak G_j[x_j]$ 是定义在 $I_j = \mathbb Z\cap[0,n_j-1] \cup \{0_{I_j}\}$ 上的普通生成函数环，其未定元为 $x_j$，那么 $\mathfrak G_1[x_1]\times \cdots \times \mathfrak G_k[x_k]$ 是 $k$ 元普通生成函数环，也可写作 $\A[x_1,\dots,x_k]/(x_1^{n_1},\dots,x_k^{n_k})$。接下来记 $n = n_1 \times \cdots \times n_k$。
\end{definition}

\subsection{卷积}

若进行朴素的高维 DFT，则每维都几乎要将数组倍长，导致 $\Omega(n2^k)$ 的计算量和空间，在高维情况是尤其不可接受的。

究其原因，DFT 若不将数组倍长，则其所实际进行的为循环卷积，下标溢出的部分会污染我们所求的答案。一个较为直接的想法是扩充一维，用于确认实际的总度数 $\sum_{l=1}^k i_l$。如此一来，我们得到了一个在 $n_l$ 均较小时高效的算法：

\paragraph{插值转化}
对于 $1\le l\le k$，若存在 $\alpha^{(l)}_0,\dots,\alpha^{(l)}_{n_l-1}$ 使得 $i\neq j \Leftrightarrow \alpha^{(l)}_i - \alpha^{(l)}_j$ 在 $\A$ 中有逆元，那么令 
$$
\tilde F = \sum_{i_1=0}^{n_1-1} \cdots \sum_{i_k=0}^{n_k-1} f_{i_1,\dots,i_k} x_1^{i_1}\cdots x_k^{i_k} t^{\sum_{l=1}^k i_l}
$$
我们称 $t$ 为\emph{占位元}，关于 $t$ 的多项式称为\emph{占位多项式}。称\emph{插值变换}将 $\tilde F$ 转化为 $\{\dot f_{i_1,\dots,i_k}(t)\}$，有
$$
\dot f_{i_1,\dots,i_k}(t) = \tilde F(\alpha^{(1)}_{i_1},\dots,\alpha^{(k)}_{i_k},t)
$$
若需计算 $F\times G$，只需将其插值转化为 $\dot f, \dot g$ 后逐项点乘，关于 $t$ 卷积，再施插值转化的逆变换，所得 $\tilde H$ 满足
$$
[x_1^{i_1}\cdots x_k^{i_k}] (F\times G) = \left[x_1^{i_1}\cdots x_k^{i_k}t^{\sum_{l=1}^k i_l}\right] \tilde H
$$
若记 $d = \sum_{l=1}^k (n_l-1)$，可见上述算法在最好情况下具有 $\Theta(\Mul(n)d + \Mul(d)n)$ 的复杂度，但其条件苛刻，且在 $d$ 大时不具有优势。但通过另一种构造，我们可以得到一种极优的复杂度：

\begin{theorem}
高维卷积可在 $\Theta(k\Mul(n))$ 时间内完成。
\end{theorem}

我们考虑将高维序列编码为非常规的进制数，即将下标 $(i_1,\dots,i_k)$ 映射到
$$
i = i_1 + i_2\cdot n_1 + \cdots + i_k \cdot n_1\cdots n_{k-1}
$$
显见，原本的下标运算对应于映射后\emph{未发生进位}的加法。

\begin{definition}[进位占位元]
定义占位函数 $\chi$ 为
$$
\chi(i) = \left\lfloor \frac{i}{n_1}\right\rfloor + \left\lfloor \frac{i}{n_1n_2}\right\rfloor + \cdots + \left\lfloor \frac{i}{n_1\cdots n_{k-1}}\right\rfloor
$$
由此函数衍生的进位占位元 $t$ 得到其占位多项式 $\tilde F = \sum_i f_i x^i t^{\chi (i)}$。
\end{definition}

\begin{lemma}
对于 $i+j<n$，占位函数满足
$$
0\le \chi(i) + \chi(j) - \chi(i+j) \le k-1
$$
其中 $0\le $ 取等当且仅当 $i,j$ 相加时不进位。
\end{lemma}

\begin{proof}
只需注意到 $0\le \left\lfloor \frac{i}{n_1}\right\rfloor + \left\lfloor \frac{j}{n_1}\right\rfloor - \left\lfloor \frac{i+j}{n_1}\right\rfloor\le 1$，其中 $0\le $ 取等当且仅当最低位加法未进位。同理可知，$\chi$ 的求和式中每一项均有相同性质。
\end{proof}

因而我们可以直接计算 $\tilde F(x,t) \times \tilde G(x, t) \bmod (t^k-1)$，第 $(i_1,\dots,i_k)$ 项即为 $x^it^{\chi(i)\bmod k}$ 次项系数。此时我们可以对 $x$ 进行 DFT，然后对 $t$ 维暴力进行 $\Theta(k^2)$ 的乘法（因为 $k\le \log_2 n$）完成计算，复杂度为 $\Theta(k\Mul(n))$。

容易发现，前述的下标映射天然赋予了一个在线算法的计算顺序，因此有

\begin{lemma}
多元在线卷积可在 $O(k\R(n))$ 完成。
\end{lemma}

值得一提的是，这一计算顺序也可以直接作用于牛顿迭代法的计算。其正确性亦不难解释，因为我们将高维卷积考虑为带有占位多项式的 $\sum_i f_i x^i t^{\chi(i)}$ 卷积时，对其进行任何运算，只会产生一些 $j < \chi(i)$ 的 $x^it^j$ 项，且这些项不会再对形如 $x^it^{\chi(i)}$ 项有贡献。因此我们实际上就是牛顿迭代的时候只维护这个多项式的 $\chi(i)$ 所构成的上轮廓。

\subsection{多元 Lagrange 反演}

当我们讨论多元 Lagrange 反演时，首先注意到的就是无法对一个多元幂级数定义复合逆，因为多元幂级数需要带入多个参数而非一个。

\begin{definition}[树形复合方程]
对于 $G_i \in R[[\mathbf x]]$，其中 $\mathbf x = (x_1, x_2, \dots, x_n)$。且 $G_i(0) \neq 0$，那么令 $\mathbf F = (F_1, F_2, \dots, F_m)$ 满足 $F_i = x_i G_i (\mathbf F)$。记 $\mathbf F$ 是由 $\mathbf G$ 定义的一组\emph{树形复合方程}。
\end{definition}

称其为\emph{树形}是很形象的，若从 OGF 的角度审视，$\mathbf G$ 可以认为是给出了一族有根树的生成关系，它规定了对于第 $i$ 种节点，每种孩子集合的设置方案数。而 $F_i$ 就是规定以第 $i$ 种节点为根的有根树。

\begin{theorem}[多元 Lagrange]
对于 $H \in R((\mathbf x))$ 和由 $\mathbf G$ 定义的树形复合方程 $\mathbf F$，记 $\mathbf x^{\mathbf k} = x_1^{k_1} x_2^{k_2} \cdots x_n^{k_n}$。有
$$
[\mathbf x^{\mathbf k}]H(\mathbf F) = [\mathbf x^{\mathbf k}] \mathbf H \mathbf G^{\mathbf k} \left \| 
\delta_{i,j} - \frac{x_j}{G_i(\mathbf x)} \frac{\partial G_i (\mathbf x)}{\partial x_j}
\right \|
$$
其中 $\|\cdot\|$ 表示对所括的矩阵取行列式。
\end{theorem}

%这里仅给出一个 $H\in R[[\mathbf x]]$ 时的组合解释，代数证明仍参看 \cite[Sec. 1.2]{combenum}。

%\begin{proof}
%只需证明 $H = \mathbf {x^m}$ 时的情况即可推及其线性组合，只需证明
%$$
%[\mathbf x^{\mathbf k}]\mathbf {F^m} = [\mathbf x^{\mathbf k}] \mathbf {x^m}\mathbf %G^{\mathbf k} \left \| 
%\delta_{i,j} - \frac{x_j}{G_i(\mathbf x)} \frac{\partial G_i (\mathbf x)}{\partial x_j}
%\right \|
%$$
%考虑先设置 $n$ 个栈，第 $i$ 个栈中放置 $k_i$ 个第 $i$ 类节点，栈中的节点表示尚未确定其孩子集合。考虑 $\mathbf{x^n}$ 依次乘入，乘入一个 $x_i$ 时表示当前 DFS 至一个 $i$ 类节点，我们从栈中取出，此时根据 $G_i$ 的系数为贡献，选择一个孩子集合的方案，将对应的孩子集合构成的 $\mathbf x$ 乘入，计算其贡献。当 $\mathbf{x^n}$ 触发的所有 DFS 尚未结束时 DFS 至一类节点 $j$，但该栈已经空，则说明 $x_j$ 的幂次此时已经超过 $k_j$，不可能贡献答案。若 $\mathbf{x^m}$ 触发的所有 DFS 顺利结束，此时设第 $i$ 个栈中还剩下 $j_i$ 个，方案合法当且仅当 $\mathbf {j=0}$，因此我们需容斥掉 $\mathbf{j\neq 0}$ 的部分，考虑接下来栈中每个元素依据 $G_i$ 决策孩子集合，那么方案被统计当且仅当每类节点的总入度等于剩余总点数。
%\end{proof}

\section{集合幂级数}

\begin{definition}[集合幂级数的集合定义]
令 $I=2^{\{1,\dots,n\}}\cup\{0\}$，对于 $S,T\in \IZ$，记集合的\emph{无交并} $S\sqcup T$ 为：
$$
S\sqcup T = \begin{cases}
S \cup T & S\cap T = \varnothing\\
0 & \mathrm{else}
\end{cases}
$$

易见定义在 $(I,\sqcup)$ 上的生成函数就是经典的集合幂级数。
\end{definition}

但我们在这里给出不同于前人的讨论方法来定义集合幂级数，由此可以更加容易地叙述其代数性质。

\begin{definition}[集合幂级数的多元幂级数定义]
我们称 $\A[x_1,\dots,x_n]/(x_1^{2},\dots,x_n^{2})$ 是 $n$ 元集合幂级数。另记为 $\A\{x_1,\dots,x_n\}$。
\end{definition}

由此可见，集合幂级数无非是多元幂级数中最为极端的情况。

\subsection{卷积}

\begin{theorem}\label{cupconv}
当 $\A$ 取任何环时，计算集合幂级数卷积的复杂度可以做到 $\Theta(n^22^n)$。
\end{theorem}

我们可以照搬高维序列卷积的计算方法，由于各维度都极小，可以采取插值转化。注意到在任意环上总是存在 $0,1$，因此我们可以直接选取 $\alpha^{(i)}_0= 0, \alpha^{(i)}_1= 1$ 进行插值转化。事实上，这就是经典的快速 M\"obius 变换以及占位多项式的表述：看做集合并卷积并且用集合大小进行占位。

\begin{theorem}
计算集合幂级数\emph{在线卷积}的复杂度可以做到 $\Theta(n^22^n)$。
\end{theorem}

这一算法最早出现于 \cite{walk}。我们令在线算法的优先级为 $\delta(S) = |S|$，我们只需令 $k$ 从小到大，处理全体 $|S|=k$ 的系数时，对应 $|S|=0,\dots,k-1$ 部分的占位多项式已经完成计算，可以在 $\Theta(k 2^n)$ 时间内计算出占位多项式在 $t^k$ 位置的乘法，然后通过 $\Theta(n2^n)$ 时间仅对 $t^k$ 部分进行 M\"obius 逆变换，从而得到所有系数。得到后再通过 $\Theta(n2^n)$ 时间仅对 $t^k$ 部分进行 M\"obius 变换。由此，整个算法的复杂度为 $\Theta(n^22^n)$。

对于不太拘泥于运算顺序的半在线集合幂卷积来说，上述算法已经足够，\cite{nimberpoly} 中将其称为\emph{半半在线}卷积。与之相对的\emph{全半在线}卷积需保证按照集合所代表的二进制数从小到大算出各项的值。后文我们将看到在特征为 $2$ 的环上这将能够用于求解指数生成函数的微分方程。

\begin{theorem}
全半在线集合幂卷积可以在 $\Theta(n^22^n)$ 时间内完成。
\end{theorem}

这一算法的进行需要将占位多项式变换为插值形式，我们取 $k$ 个插值点，那么插值转化后的乘法可以在 $\Theta(k2^n)$ 内完成。我们考虑从最高位开始进行分治，由于 M\"obius 变换的每一位都可以在 $\Theta(k2^n)$ 内完成，我们在分治过程中每次仅对最高位进行变换即可，具体过程可参见下述伪代码。

\begin{breakablealgorithm}
  \caption{Fully Relaxed Subset Convolution}
  \begin{algorithmic}[1]
    \REQUIRE A number $n$, an array $g[1\dots 2^n-1]$, relaxing function $\phi$ will modify $f[i]$ when calling $\phi(i)$
    \ENSURE Evaluate $f[i]$ and call $\phi(i)$ in the order $i=0\dots 2^n-1$
   
    \STATE Find $k$ elements $a_1,\dots,a_k\in \A$ such that $\forall i\neq j$, $a_i-a_j$ is invertible
    \STATE Let $\mathbf A = (a_i^j)_{i,j=0}^{k-1}$ and precalculate $\mathbf A^{-1}$
    \STATE Initialize $\mathbf F[0\dots 2^n-1]$ with $\mathbf 0$
    \FOR {$i=0\dots 2^n-1$}
      \STATE Let $b = \operatorname{\mathbf{popcount}}(i)$
      \STATE $\mathbf G[i] \leftarrow (g[i] \mathbf A)_b$
    \ENDFOR
    \FOR {$i=0\dots n-1$}
      \STATE Do M\"obius transform on $\mathbf G[2^i\dots 2^{i+1}-1]$
    \ENDFOR
    \STATE \textbf{function} DivideConquer($l, t$) \COMMENT {solve $[l, l+2^t)$}
    \begin{ALC@g} % 烂招，因为 noithesis.cls 直接把 algorithms 引了，由于冲突没法用其他有 function 的库
    \IF {$t=0$}
      \STATE Let $b = \operatorname{\mathbf{popcount}}(l)$
      \STATE $f[l] \leftarrow (\mathbf F[l] \mathbf A^{-1})_b$ 
      \STATE $\phi(l)$
      \STATE $\mathbf F[l] \leftarrow (f[l] \mathbf A)_b$
    \ELSE
      \FOR {$i = l \dots l + 2^{t-1}-1$}
        \STATE $\mathbf F[i + 2^{t-1}] \leftarrow \mathbf F[i + 2^{t-1}] + \mathbf F[i]$
      \ENDFOR
      \STATE DivideConquer($l, t-1$)
      \FOR {$i = l \dots l + 2^{t-1}-1$}
        \STATE $\mathbf F[i + 2^{t-1}] \leftarrow \mathbf F[i + 2^{t-1}] + \mathbf F[i] \cdot \mathbf G[i + 2^{t-1}]$
      \ENDFOR
      \STATE DivideConquer($l+2^{t-1}, t-1$)
    \ENDIF
    \end{ALC@g}
    \STATE \textbf{end function}
    \STATE DivideConquer($0, n$)
  \end{algorithmic}
\end{breakablealgorithm}

整体复杂度为 $T(n)=2T(n-1)+\Theta(k2^n)=\Theta(kn2^n)$。由于过程中得到的多项式最高次数为 $2n-1$，取 $k=2n$ 已足够。如能够取单位根进行循环卷积，则取 $k\ge n$ 已足够。

\subsubsection{形式幂转化}

集合幂的形式幂转化由定理 \ref{cupconv} 使用的算法一脉相承，其思想自 \cite{vfk} 引入之初便已成型。与一般高维卷积相反之处在于，插值转化后采取的占位多项式上的乘法不采取循环卷积，因而在进行多次变换之后所求的值不会被污染。因此，若集合幂级数的计算过程中有一连串计算，可始终在插值转化的状态下进行计算。后文中我们将会看到这一特点有时能够优化理论复杂度，此外在实际应用时，这也能够有效地减小算法的常数。

\subsection{逐点牛顿迭代法}

考虑为了计算得到某个集合幂 $F$ 时，我们分解为计算 $\frac{\partial}{\partial x_n} F$ 和 $\left . F \right |_{x_n=0}$。此时，前者等价于 $[x_n^1]$ 部分，后者等价于 $[x_n^0]$ 部分。

若我们确定了 $[x_n^0]$ 之后就能够通过 $\Theta(f(n))$ 的时间计算出 $[x_n^1]$，那么总复杂度也是 $\Theta(f(n))$ 的。（显然 $f(n) = \Omega(2^n)$）

我们称这一方法为集合幂上的\emph{逐点牛顿迭代法}。

\begin{problem}[无根树计数]
给一对称矩阵 $\mathbf G$，对于每个非空子集 $S$，求和
$$
\sum_T \prod_{(i, j) \in T} \mathbf G_{ij}
$$

其中 $T$ 枚举了以 $S$ 为点集的所有生成树。
\end{problem}

\begin{solution}
我们不妨只考虑 $n$ 号点，先计算出所有 $S\not \ni n$ 的情况，也即 $[x_n^0]F$，对于 $[x_n^1]F$ 部分，去掉 $n$ 号点后的各部分为选择了一个根的树。对于一个子集 $T$，若其自成一个连通块，那么可以任选其中一个节点为根，因此我们将 $[x^T][x_n^0]f$ 乘以 $\sum_{j\in T} \mathbf G_{jn}$ 得到 $\widehat F$，那么有
$$
[x_n^1]F = \exp \widehat F
$$

集合幂级数 $\exp$ 可在 $\Theta(n^22^n)$ 内计算，故该问题复杂度为 $\Theta(n^22^n)$。
\end{solution}

\subsubsection{复合}

\begin{definition} [集合幂级数复合]
给出 $\A$ 上的 $n$ 次\emph{指数生成函数}形式的多项式 $F = \sum_{k=0}^n f_k \frac{x^k}{k!}$ 和不含常数项的集合幂级数 $G \in \A\{x_1, \dots, x_n\}$。记其复合为
$$
F\circ G = \sum_{k=0}^n f_k\frac{G^k}{k!}
$$

注意当 $G$ 不含常数项时，$\frac{G^k}{k!}$ 总是良定义的。因为任取 $k$ 个非空不交集合 $S_1,\dots S_k$，记 $\bigsqcup_{j=1}^k S_j = S$，此时 $S_1,\dots S_k$ 的 $k!$ 个置换均贡献给 $x^S$ 项的系数。因此我们不妨直接定义 $[x^S]\frac{G^k}{k!}$ 为对于全体将 $S$ 划分为 $k$ 个无序非空集合 $S_1,\dots S_k$ 的方案，对于 $\prod_{i=1}^k [x^{S_i}]G$ 求和。
\end{definition}

\begin{theorem}
集合幂级数复合可以在 $\Theta(n^22^n)$ 时间内完成计算。
\end{theorem}

考虑 $\frac{\partial}{\partial x_n} (F \circ G) = F'(G)\frac{\partial}{\partial x_n} G$，故我们将其规约为 $n-1$ 的子问题，但要计算 $F$ 和 $F'$ 对其复合的结果。

记 $G_k$ 为 $\left. G \right |_{x_n = \dots x_{n-k+1}=0}$，归纳可知，对于 $0\le k\le n$，我们需要解决 $F, F', \dots, F^{(k)}$ 复合 $G_k$ 这 $k+1$ 个规模为 $n-k$ 的复合问题。

我们依此顺序计算，瓶颈为对于每个 $k$，我们进行了 $n-k$ 次 $k$ 元集合幂级数乘法，其复杂度可由和式 $\Theta \left(\sum_{k=0}^n k^2 2^k (n-k)\right)$ 表示。下面证明其复杂度就是 $\Theta(n^2 2^n)$。

\begin{proof}
经计算可得：
$$
\sum_{k=0}^n k^2 2^k (n-k) = 2(-13 + 13\cdot 2^n - 3n - 6\cdot 2^n n+ 2^n n^2)
$$

由此，该算法的复杂度为 $\Theta(n^2 2^n)$。
\end{proof}

事实上，这一方法具有极好的常数。对于集合幂 $\exp$ 来说，由于 $F'=F$，我们可以在迭代过程中减少一些维护，这种方法在常数上较进行 $2^n$ 次微分方程实现 $\Theta(n^2)$ 形式幂 $\exp$ 的方法效率更高。

\begin{lemma}
集合幂级数复合在插值转化的情形下可以 $\Theta(2^n\Mul(n))$ 完成计算。
\end{lemma}

为了达成这一理论复杂度，主要在于将上一算法的各步骤精细处理。首先，我们不需要得到 $G_k$，而只需要得到 $G_k$ 一个插值转化的结果，我们首先对 $G$ 在 $x_n$ 这一维解除插值，这只需要 $\Theta(n2^n)$ 的复杂度，便得到了 $\frac{\partial}{\partial x_n} G$ 和 $G_0$ 的插值结果，对 $G_0$ 继续递归即可得到所有 $G_k$ 的插值结果，复杂度为 $\sum_{k=1}^n k2^k = \Theta(n2^n)$。反之，所有子问题的计算瓶颈也皆为多项式乘法，因此复杂度为 $\sum_{k=0}^n \Mul(k) 2^k(n-k) = \Theta(2^n\Mul(n))$。

\subsubsection{Tutte 多项式}

\begin{definition}
对于无向图 $G = (V, E)$，定义其 \emph{Tutte 多项式}为
$$T_G(x,y)=\sum_{A\subseteq E}(x-1)^{k(A)-k(E)}(y-1)^{k(A)+|A|-|V|}$$

其中 $k(E)$ 表示图 $(V, E)$ 的连通分量数。
\end{definition}

接下来的几条资料显示了 Tutte 多项式与几个经典的图上计数问题的联系。由于篇幅所限，下面的几条引理仅述而不证。

\begin{definition}[色多项式]
对于无向图 $G = (V, E)$，存在多项式 $P_G(k)$ 使得带入正整数 $k$ 时，$P_G(k)$ 的值表示 $G$ 的 $k$-染色方案。
\end{definition}

\begin{lemma}
色多项式可表为 Tutte 多项式：
$$P_G(c)=(-1)^{|V|-k(E)}c^{k(E)}T_G(1-k, 0)$$
\end{lemma}

\begin{lemma}
对于一个无向图 $G = (V, E)$，下式
$$(-1)^{|V|}P_G(-1)=T_G(2,0)$$

为 $G$ 的\emph{无环定向}数量，即给每条边进行定向，使得图是有向无环图的方案数。
\end{lemma}

\begin{lemma}
对于一个无向图 $G = (V, E)$，$T_G(0,2)$ 为 $G$ 的\emph{强连通定向}数量，即给每条边进行定向，使得图是强连通图。
\end{lemma}

由上述引理可见，Tutte 多项式统一了几个经典的图论计数问题，只要 Tutte 多项式的计算得到解决，则可以一并解决以上几个问题。

\begin{theorem}
设 $n=|G|$，带入一组 $x,y$，$T_G(x,y)$ 可以在 $\Theta(n^2 2^n)$ 时间内计算。
\end{theorem}

\subsection{复合方程}

\subsubsection{点双连通-连通变换}

\begin{theorem}
点双连通-连通变换可在 $\Theta(n^22^n\Mul(n))$ 时间内计算。
\end{theorem}

这一算法首先由 \cite{b2c} 提出。

\section{指数生成函数}

如若 $1\sim n$ 在所进行计算的环上均同态可逆，那么指数生成函数没有额外讨论的意义，因为我们可以直接将序列变换为 $\widehat {f_n} = \frac {f_n}{n!}$。但若 $\A$ 是具有小质数因子的同余运算 $\mathbb Z/M\mathbb Z$，或者特征不为 $0$ 且小于等于 $n$ 的有限域之类，便不能直接除以 $n!$ 进行处理。我们首要需要解决的便是乘法如何进行。

\subsection{卷积}

\begin{definition}[二项卷积]
对于以 $\mathbb Z_{\ge 0}$ 为下标，以 $\A$ 为系数的序列，我们定义其卷积 $c = a * b$：
$$
c_k = \sum_{i = 0}^k \binom k i a_i b_{k-i}
$$
\end{definition}

\begin{theorem}[四模数 NTT]
在模 $M$ 运算下，存在 $\Theta(n\log n \cdot \omega(M))$\footnote{$\omega(n)$ 指 $n$ 的互异质因子数量} 复杂度的二项卷积算法。
\end{theorem}

我们考虑首先如何解决 $M = p^k$ 时的情况，然后可以用 CRT 合并各情况。

我们记 $v_p(n)$ 是 $n!$ 中 $p$ 的质因子次数，$p$-阶乘为 $n!_p = p^{v_p(n)}$，反 $p$-阶乘为 $\overline{n!_p} = \frac{n!}{n!_p}$。

那么由定义显然 $\overline{n!_p}$ 还是同余 $M$ 可逆的。我们先令 $\widehat a_n = a_n \cdot \left( \overline{n!_p} \right)^{-1} \bmod M$，我们可以得到
$$
\widehat c_n \equiv \sum_k \left(\frac{n!_p}{k!_p (n-k)!_p}\right) \widehat a_k \widehat b_{n-k} \equiv \sum_k p^{v_p(n)-v_p(k)-v_p(n-k)} \widehat a_k \widehat b_{n-k} \pmod M
$$

\begin{theorem}[Kummer]

$v_p(n)-v_p(k)-v_p(n-k)$ 就是在 $p$ 进制下，$n$ 减去 $k$ 时所发生的退位次数。

\end{theorem}

由于 $n$ 在 $p$ 进制下最多只有 $\log_p n$ 位可退，根据上述定理我们知道 $p^d \le n$，因此我们在\emph{不取模}的情况下，可以得到 $\widehat c_n \le n \cdot nM^2 = n^2M^2$。

虽然 $p$ 在模 $M$ 下不可逆，但是当 $p\le n$，自然满足在我们选取的 NTT 模数下都可逆。因此，这一涉及除法的卷积式子，因为已经保证了结果是值域在 $n^2M^2$ 内的整数，所以我们只需选取 NTT 模数进行卷积，之后用 CRT 合并即可。取 $n\le 10^6, M\le 10^9$ 的一般情况下，可得 $c_n \le 10^{30}$，使用四个 NTT 模数进行合并足够。目前美中不足的是，在通常的 $M$ 在 $10^9$ 范围内，就已经不可避免地在四模数 NTT 最后的 CRT 阶段使用 \texttt{int128}。

因此对于每个 $M=p^k$ 的情况，我们都可以通过\emph{四模数 NTT}进行计算，那么对于一般的 $M$ 进行 CRT，算法的复杂度为 $\Theta(n\log n \cdot \omega(M))$，或者也可以解释为，结果值域为 $n^{1+\omega(M)}M^2$ 的卷积。

\begin{theorem}
模 $M$ 二项卷积可在 $\Theta(\R(n)\cdot \omega(M))$ 时间内在线进行。
\end{theorem}

经过 CRT 转化，我们将在线二项卷积转化为 $\omega(M)$ 个易于进行的 $M=p^k$ 形式的在线二项卷积。通过前述的四模数 NTT 规约，我们将在线二项卷积转化为四个同步进行的在线卷积。

通过此法，我们也可以较为高效地完成二项运算下的初等函数复合。

\begin{theorem}
对于多项式 $f(x)$ 和 EGF 形式的多项式 $g(x)$，设 $\mathrm{D} = \frac{\mathrm{d}}{\mathrm{d}x}$，可以在 $\Theta(n\log n \cdot \omega(M))$ 的时间内计算求导算子对多项式的乘法 $g(\mathrm{D}) \cdot f(x)$。
\end{theorem}

只需注意到将 $f(x)$ 的系数看做输入向量 $\mathbf f$，那么这一变换是「将 $f$ 与 $g$ 做二项卷积」的转置算法，我们对二项卷积的过程进行转置计算即可。

\begin{lemma}
对于多项式 $f(x)$，可以在 $\Theta(n\log n \cdot \omega(M))$ 时间内计算 $f(x+c)$ 同余 $M$ 的各项系数。
\end{lemma}

只需注意到 $f(x+c) = \mathrm{e}^{c\mathrm{D}} \cdot f(x)$ 即可规约到上述算法。

\begin{lemma}
已知多项式 $f(x)$ 在 $0,\dots,n$ 下的点值（且在同余 $M$ 下存在且以此形式给出），可以在 $\Theta(n\log n \cdot \omega (M))$ 内求 $f(m),f(m+1),\dots,f(m+n)$ 在同余 $M$ 下的点值。
\end{lemma}

\section{狄利克雷生成函数}

\begin{definition}
令 $I = \mathbb Z \cap [0, n]$，对于 $i,j\in \IZ$，令
$$
i\circ j = \begin{cases}
ij & ij \le n\\
0 & \mathrm{else}
\end{cases}
$$

定义在 $(I,\circ)$ 上的生成函数即为我们计算时取的狄利克雷生成函数（DGF）。

另外，不同于其他生成函数记号，狄利克雷生成函数常记为 $F(s) = \sum_n \frac{a_n}{n^s}$。其序列卷积常称为狄利克雷卷积。
\end{definition}

\subsection{卷积}

\begin{theorem}
狄利克雷卷积可在 $\Theta(n\log n)$ 时间内\emph{在线}进行。
\end{theorem}

由于 $ij\le n$ 的 $(i,j)$ 数量仅有 $\Theta(n\log n)$ 个，只需预处理每个 $k$ 对应的所有 $i$ 即可。这一事实已为人熟知，在此不予赘述。

\section{总结}

本文中，我们简要勾勒出了生成函数计算时问题的主要分支、计算时的不同难度层次、以及解决对应的问题的部分纲领。然而吾生也有涯，而知也无涯，本文的理论还有无数的空缺之处以及开放性问题尚待解决。希望能有感兴趣的同学发挥愚公移山之精神，进一步完善生成函数计算的理论图景。

\section*{致谢}

感谢中国计算机学会提供学习和交流的平台。

感谢北大附中肖然老师的关心和指导。

感谢家人、朋友对我的支持与鼓励。

感谢赵雨扬前辈与我讨论以及给予的启发，以及其对于集合幂级数等相关部分前瞻性的理解。

感谢XX为本文审稿。

\begin{thebibliography}{99}
\bibitem{polyfact} Kedlaya, Kiran \& Umans, Christopher. (2008). Fast Polynomial Factorization and Modular Composition. SIAM Journal on Computing. 40. \DOI{10.1137/08073408X}
\bibitem{tellegen} 陈宇，赵雨扬，曾致远。(2020)。转置原理的简单介绍。IOI2020 中国国家集训队论文集。
\bibitem{relaxmul} Hoeven, Joris. (2007). New algorithms for relaxed multiplication. \DOI{10.1016/j.jsc.2007.04.004} 
\bibitem{nimberpoly} 罗煜翔。(2020)。浅谈 Nimber 和多项式算法。IOI2020 中国国家集训队论文集。
\bibitem{fastlinearrec} Bostan, A. \& Mori, Ryuhei. (2020). A Simple and Fast Algorithm for Computing the $N$-th Term of a Linearly Recurrent Sequence. \DOI{10.1137/1.9781611976496.14}
\bibitem{zzq} 钟子谦。(2019)。两类递推数列的性质和应用。IOI2019 中国国家候选队论文集。
%\bibitem{palg} Bostan, Alin and Christol, Gilles and Dumas, Philippe. (2016). Fast Computation of the $N$-th Term of an Algebraic Series over a Finite Prime Field. In Proceedings of the ACM on International Symposium on Symbolic and Algebraic Computation (ISSAC '16). Association for Computing Machinery, New York, NY, USA, 119–126. \DOI{10.1145/2930889.2930904}
\bibitem{combenum} Goulden, Ian P., and David M. Jackson. Combinatorial Enumeration. 2004.
\bibitem{walk} 洪华敦。(2018)。《「WC2018」州区划分》解题报告。
\bibitem{vfk} 吕凯风。(2015)。集合幂级数的性质与应用及其快速算法。IOI2015 中国国家候选队论文集。
\bibitem{b2c} 赵雨扬。(2019)。《点双连通生成子图计数》题解。由马耀华同学代为撰写：\url{https://loj.ac/d/2668}
\end{thebibliography}
